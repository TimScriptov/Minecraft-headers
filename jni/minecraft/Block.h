/***
 *	MCPE 1.13.0.1
 ***/
#pragma once

class BlockProperty;
class AABB;
class ActorBlockSyncMessage;
class FertilizerType;
class Random;
class BlockSupportType;
class SpawnConditions;
class ItemState;

class Block
{
public:
	//char filler_Block[UNKNOW_SIZE];
public:
	virtual ~Block();
	virtual void getRenderLayer() const;
public:
	//Block(unsigned short, WeakPtr<BlockLegacy>&);
	void getMaterial() const;
	void hasProperty(BlockProperty) const;
	void getGravity() const;
	void getVariant() const;
	void isSeasonTinted(BlockSource&, BlockPos const&) const;
	void getColorForParticle(BlockSource&, BlockPos const&, Block const&) const;
	void getRuntimeId() const;
	void getVisualShape(AABB&, bool) const;
	void getColor() const;
	void getTranslucency() const;
	void hasRuntimeId() const;
	void canSurvive(BlockSource&, BlockPos const&) const;
	void getUIShape(AABB&) const;
	void calcVariant(BlockSource&, BlockPos const&) const;
	void getColorAtPos(BlockSource&, BlockPos const&) const;
	void getMappedFace(unsigned char) const;
	void canHaveExtraData() const;
	void getLightEmission() const;
	void getLiquidClipVolume(BlockSource&, BlockPos const&, AABB&) const;
	void isSolidBlockingBlock() const;
	void getVisualShapeInWorld(BlockSource&, BlockPos const&, AABB&, bool) const;
	void getConnectedDirections(BlockPos const&, BlockSource&, bool&, bool&, bool&, bool&) const;
	void randomlyModifyPosition(BlockPos const&) const;
	void randomlyModifyPosition(BlockPos const&, int&) const;
	void liquidCanFlowIntoFromDirection(unsigned char, std::function<Block const& (BlockPos const&)>, BlockPos const&) const;
	void isSolid() const;
	void getColor(BlockSource&, BlockPos const&) const;
	void getBlockEntityType() const;
	void getExtraRenderLayers() const;
	void isStandingSign() const;
	void getAABB(BlockSource&, BlockPos const&, AABB&, bool) const;
	void getRenderLayer(BlockSource&, BlockPos const&) const;
	void ignoreBlockForInsideCubeRenderer() const;
	void DEPRECATEDcallOnGraphicsModeChanged(bool, bool, bool, bool);
	void getOutline(BlockSource&, BlockPos const&, AABB&) const;
	void getSecondPart(BlockSource&, BlockPos const&, BlockPos&) const;
	void getCollisionShape(AABB&, BlockSource&, BlockPos const&, Actor*) const;
	void isInteractiveBlock() const;
	void isCraftingBlock() const;
	void isContainerBlock() const;
	void canBeBuiltOver(BlockSource&, BlockPos const&) const;
	void mayPlace(BlockSource&, BlockPos const&) const;
	void getSerializationId() const;
	void getShadeBrightness() const;
	void destroy(BlockSource&, BlockPos const&, Actor*) const;
	void isHeavy() const;
	void asItemInstance(BlockSource&, BlockPos const&) const;
	void attack(Player*, BlockPos const&) const;
	void mayPick() const;
	void transformOnFall(BlockSource&, BlockPos const&, Actor*, float) const;
	void entityInside(BlockSource&, BlockPos const&, Actor&) const;
	void isStairBlock() const;
	void pushesOutItems() const;
	//void addCollisionShapes(BlockSource&, BlockPos const&, AABB const*, std::vector<AABB, std::allocator<AABB> >&, Actor*) const;
	void dealsContactDamage(Actor const&, bool) const;
	void updateEntityAfterFallOn(Actor&) const;
	void onFallOn(BlockSource&, BlockPos const&, Actor*, float) const;
	void onStepOn(Actor&, BlockPos const&) const;
	void isCropBlock() const;
	void checkIsPathable(Actor&, BlockPos const&, BlockPos const&) const;
	void hasTag(BlockSource&, BlockPos const&, Block const&, std::string const&) const;
	void spawnResources(BlockSource&, BlockPos const&, float, int) const;
	void getFriction() const;
	void tryToPlace(BlockSource&, BlockPos const&, ActorBlockSyncMessage const*) const;
	void hasBlockEntity() const;
	void shouldStopFalling(Actor&) const;
	void breaksFallingBlocks() const;
	void pushesUpFallingBlocks() const;
	void canBeBrokenFromFalling() const;
	void calcGroundFriction(Mob&, BlockPos const&) const;
	void isBounceBlock() const;
	void getDestroySpeed() const;
	void isEmpty() const;
	void isFenceBlock() const;
	void playerDestroy(Player&, BlockPos const&) const;
	void telemetryVariant(BlockSource&, BlockPos const&) const;
	void playerWillDestroy(Player&, BlockPos const&) const;
	void use(Player&, BlockPos const&) const;
	void getDescriptionId() const;
	void getPlacementBlock(Actor&, BlockPos const&, unsigned char, Vec3 const&, int) const;
	void onFertilized(BlockSource&, BlockPos const&, Actor*, FertilizerType) const;
	void mayConsumeFertilizer(BlockSource&) const;
	void canHurtAndBreakItem() const;
	void buildDescriptionId() const;
	void getMapColor(BlockSource&, BlockPos const&) const;
	void getMapColor() const;
	void isMotionBlockingBlock() const;
	void getLight() const;
	//void getDebugText(std::vector<std::string, std::allocator<std::string> >&, BlockPos const&) const;
	void isObstructingChests(BlockSource&, BlockPos const&) const;
	void getComparatorSignal(BlockSource&, BlockPos const&, unsigned char) const;
	void hasComparatorSignal() const;
	void isSolidBlockingBlockAndNotSignalSource() const;
	void movedByPiston(BlockSource&, BlockPos const&) const;
	void ignoreEntitiesOnPistonMove() const;
	void isAttachedTo(BlockSource&, BlockPos const&, BlockPos&) const;
	void isRailBlock() const;
	void buildSerializationId(unsigned int);
	void getPlacementFacingAll(Actor&, BlockPos const&, float);
	void getPlacementFacingAllExceptAxisY(Actor&, BlockPos const&, float);
	void canConnect(Block const&, unsigned char, Block const&) const;
	void mayPlaceOn(BlockSource&, BlockPos const&) const;
	void onExploded(BlockSource&, BlockPos const&, Actor*) const;
	void animateTick(BlockSource&, BlockPos const&, Random&) const;
	void getBurnOdds() const;
	void isDoorBlock() const;
	void isSlabBlock() const;
	void isStemBlock() const;
	void isWallBlock() const;
	void popResource(BlockSource&, BlockPos const&, ItemInstance const&) const;
	void canInstatick() const;
	void getFlameOdds() const;
	void getThickness() const;
	void isStrippable(Block const&) const;
	void setFlammable(int, int) const;
	void setRuntimeId(unsigned int const&) const;
	void triggerEvent(BlockSource&, BlockPos const&, int, int) const;
	void getMobToSpawn(SpawnConditions const&, BlockSource&) const;
	void getProperties() const;
	void isAlphaTested() const;
	void isButtonBlock() const;
	void isInteraction() const;
	void isUnbreakable() const;
	void toDebugString() const;
	void getAllowsRunes() const;
	void getFlexibility(BlockSource&, BlockPos const&) const;
	void getIconYOffset() const;
	void isSignalSource() const;
	void shouldDispense(BlockSource&, Container&) const;
	void spawnResources(BlockSource&, BlockPos const&, Block const&, float, int) const;
	void getDirectSignal(BlockSource&, BlockPos const&, int) const;
	void isHurtableBlock() const;
	void isWaterBlocking() const;
	void neighborChanged(BlockSource&, BlockPos const&, BlockPos const&) const;
	void onProjectileHit(BlockSource&, BlockPos const&, Actor const&) const;
	void canBeSilkTouched() const;
	void getResourceCount(Random&, int) const;
	void getStrippedBlock() const;
	void isFenceGateBlock() const;
	void isThinFenceBlock() const;
	void shouldRandomTick() const;
	void canProvideSupport(unsigned char, BlockSupportType) const;
	void getExperienceDrop(Random&) const;
	void handleEntityInside(BlockSource&, BlockPos const&, Actor*, Vec3&) const;
	void spawnBurnResources(BlockSource&, float, float, float) const;
	void getCreativeCategory() const;
	void hasVariableLighting() const;
	void buildDescriptionName() const;
	void canBeOriginalSurface() const;
	void getExplosionResistance(Actor*) const;
	void getSilkTouchItemInstance() const;
	void getParticleQuantityScalar() const;
	void shouldRandomTickExtraLayer() const;
	void getIgnoresDestroyPermissions(Actor&, BlockPos const&) const;
	void isAuxValueRelevantForPicking() const;
	void clip(BlockSource&, BlockPos const&, Vec3 const&, Vec3 const&, bool) const;
	void clip(BlockSource&, BlockPos const&, Vec3 const&, Vec3 const&, bool, AABB const&) const;
	void tick(BlockSource&, BlockPos const&, Random&) const;
	//void addAABB(AABB const&, AABB const*, std::vector<AABB, std::allocator<AABB> >&) const;
	void mayPick(BlockSource&, bool) const;
	void onPlace(BlockSource&, BlockPos const&) const;
	//void addAABBs(BlockSource&, BlockPos const&, AABB const*, std::vector<AABB, std::allocator<AABB> >&) const;
	void canSlide(BlockSource&, BlockPos const&) const;
	void dispense(BlockSource&, Container&, int, Vec3 const&, unsigned char) const;
	void mayPlace(BlockSource&, BlockPos const&, unsigned char) const;
	void onRemove(BlockSource&, BlockPos const&) const;
	void copyState(Block const&, ItemState const&) const;
	void keepState(ItemState const&) const;
public:
	static Block * SIZE_OFFSET;
	static Block * BLOCK_DESCRIPTION_PREFIX;
};
